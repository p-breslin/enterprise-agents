import asyncio
import logging
from tavily import AsyncTavilyClient
from typing import Dict, Any, Optional, Callable

from .base_agent import BaseAgent
from scripts.state import OverallState
from scripts.events import Event, EventType
from utilities.helpers import filter_searches, get_api_key

logger = logging.getLogger(__name__)


class WebSearchAgent(BaseAgent):
    """
    Executes web searches using the web search tool using queries generated by upstream agents.

    Behavior:
        1. Listens for QUERIES_GENERATED.
        2. Executes multiple web searches asynchronously.
        3. Stores the results in shared state and publishes SEARCH_RESULTS_READY.
    """

    def __init__(self, name: str, state: OverallState, config: Dict[str, Any]):
        super().__init__(name, state)
        self.cfg = config

    async def handle_event(
        self,
        event: Event,
        event_queue,
        progress_callback: Optional[Callable[[Dict], None]],
    ) -> None:
        """
        Purpose:
            Entry point for the agent's behavior in response to events.
        Notes:
            Expects QUERIES_GENERATED as the trigger.
        """
        # Initialize progress manager
        self.setup_progress(progress_callback)

        if event.type == EventType.QUERIES_GENERATED:
            self.update_status(
                "Received QUERIES_GENERATED event, preparing web searches..."
            )

            try:
                await self.web_search(event_queue)
            except Exception as e:
                self.update_status(f"Web search failed: {e}", type_="error")
                await self.publish_event(
                    event_queue,
                    Event(
                        EventType.ERROR_OCCURRED,
                        payload={"error": f"WebSearchAgent failed: {e}"},
                    ),
                )

    async def web_search(self, event_queue) -> None:
        """
        Purpose:
            Executes web searches using the web search tool and the generated queries from the QueryGenerationAgent.
        Notes:
            Results are filtered and stored in state.search_results.
        """

        self.update_status("Performing Tavily web search...")

        # Web search tool API
        tavily_api_key = get_api_key(service="TAVILY")
        tavily_async_client = AsyncTavilyClient(tavily_api_key)

        # Web search tool parameters from config
        runtime_settings = self.cfg.get("runtime_settings", {})
        tavily_params = runtime_settings.get("tavily_search_params", {})

        # Skip search if no queries
        if not self.state.search_queries:
            self.update_status(
                "No search queries found. Skipping search.", type_="warning"
            )
            self.state.search_results = []
            await self.publish_event(event_queue, Event(EventType.SEARCH_RESULTS_READY))
            return

        # Asynchronous web searches
        self.update_status(
            f"Preparing {len(self.state.search_queries)} web search tasks..."
        )

        tasks = []
        for query in self.state.search_queries:
            try:
                tasks.append(tavily_async_client.search(query, **tavily_params))
            except Exception as e:
                self.update_status(
                    f"Failed to queue search for '{query}': {e}", type_="error"
                )

        if not tasks:
            self.update_status(
                "No valid search tasks could be prepared.", type_="warning"
            )
            self.state.search_results = []
            await self.publish_event(event_queue, Event(EventType.SEARCH_RESULTS_READY))
            return

        try:
            # Execute all search tasks concurrently
            self.update_status(f"Executing {len(tasks)} search tasks...")
            search_results = await asyncio.gather(*tasks)
            self.update_status("Tavily searches completed.")
        except Exception as e:
            self.update_status(f"Async search execution failed: {e}", type_="error")
            raise e

        # Process and store results
        self.update_status("Processing search results...")
        unique_results = filter_searches(search_results)  # filter duplicates
        self.state.search_results = unique_results
        self.update_status(f"Stored {len(unique_results)} search results.")

        await self.publish_event(event_queue, Event(EventType.SEARCH_RESULTS_READY))
